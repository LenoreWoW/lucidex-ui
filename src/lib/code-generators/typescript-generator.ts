import { Component, GeneratedCode } from '@/types';
import { CodeGeneratorOptions, toPascalCase, PropDefinition } from './index';

export function generateTypeScriptCode(
  component: Component,
  options: CodeGeneratorOptions
): GeneratedCode {
  const componentName = toPascalCase(component.name);
  const filename = `${componentName}.types.ts`;

  // Extract props from component
  const props: PropDefinition[] =
    component.props?.map(prop => ({
      name: prop.name,
      type: prop.type,
      required: prop.required || false,
      defaultValue: prop.default,
      description: prop.description,
    })) || getDefaultProps();

  // TypeScript specific dependencies
  const dependencies = ['typescript'];
  const imports = ['typescript'];

  // Generate TypeScript code
  const code = generateTypeScriptInterfaces(
    componentName,
    props,
    options,
    component
  );

  return {
    framework: 'typescript',
    filename,
    code,
    language: 'typescript',
    imports,
    dependencies,
    installationSteps: [
      'npm install -D typescript @types/node',
      'npx tsc --init',
      'Configure tsconfig.json for your project needs',
    ],
    usageNotes: [
      `Import types: import { ${componentName}Props, ${componentName}Config } from './${componentName}.types';`,
      'Use with React, Vue, Angular, or any TypeScript project',
      'Provides strong typing and IntelliSense support',
      'Includes utility types and helper functions',
      'Supports generic constraints and advanced type patterns',
    ],
  };
}

function generateTypeScriptInterfaces(
  componentName: string,
  props: PropDefinition[],
  options: CodeGeneratorOptions,
  component: Component
): string {
  const mainInterface = generateMainInterface(componentName, props, options);
  const utilityTypes = generateUtilityTypes(componentName, props);
  const helperFunctions = generateHelperFunctions(
    componentName,
    props,
    options
  );
  const constants = generateConstants(componentName, component);
  const exports = generateExports(componentName);

  const parts = [
    ...(options.includeComments
      ? [generateHeader(componentName, component)]
      : []),
    '',
    generateImports(),
    '',
    mainInterface,
    '',
    utilityTypes,
    '',
    constants,
    '',
    helperFunctions,
    '',
    exports,
  ];

  return parts.filter(Boolean).join('\n');
}

function generateHeader(componentName: string, component: Component): string {
  return `/**
 * TypeScript interfaces and types for ${componentName} component
 *
 * ${component.description || `Provides type definitions for the ${componentName} component`}
 *
 * @version 1.0.0
 * @author Generated by Lucidex UI Explorer
 */`;
}

function generateImports(): string {
  return `// Standard React types (if used with React)
// import { ReactNode, HTMLAttributes, ComponentPropsWithoutRef } from 'react';

// Utility types
type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};`;
}

function generateMainInterface(
  componentName: string,
  props: PropDefinition[],
  options: CodeGeneratorOptions
): string {
  const interfaceProps = props
    .map(prop => {
      const optional = prop.required ? '' : '?';
      const comment =
        options.includeComments && prop.description
          ? `  /** ${prop.description} */\n`
          : '';

      return `${comment}  ${prop.name}${optional}: ${prop.type};`;
    })
    .join('\n');

  const baseInterface = `/**
 * Props interface for ${componentName} component
 */
export interface ${componentName}Props {
${interfaceProps}
}`;

  const configInterface = `/**
 * Configuration interface for ${componentName} component
 */
export interface ${componentName}Config {
  /** Component variant */
  variant?: 'default' | 'outline' | 'ghost';
  /** Component size */
  size?: 'sm' | 'md' | 'lg';
  /** Component theme */
  theme?: 'light' | 'dark';
  /** Animation settings */
  animation?: {
    duration?: number;
    easing?: string;
    disabled?: boolean;
  };
  /** Accessibility settings */
  accessibility?: {
    label?: string;
    description?: string;
    role?: string;
  };
}`;

  return `${baseInterface}\n\n${configInterface}`;
}

function generateUtilityTypes(
  componentName: string,
  props: PropDefinition[]
): string {
  const variantProps = props.filter(
    prop =>
      prop.type.includes('|') ||
      prop.name.includes('variant') ||
      prop.name.includes('size')
  );

  const utilityTypes: string[] = [];

  // Required props type
  const requiredProps = props.filter(prop => prop.required);
  if (requiredProps.length > 0) {
    utilityTypes.push(`/**
 * Required props for ${componentName}
 */
export type ${componentName}RequiredProps = Pick<${componentName}Props, ${requiredProps.map(p => `'${p.name}'`).join(' | ')}>;`);
  }

  // Optional props type
  const optionalProps = props.filter(prop => !prop.required);
  if (optionalProps.length > 0) {
    utilityTypes.push(`/**
 * Optional props for ${componentName}
 */
export type ${componentName}OptionalProps = Pick<${componentName}Props, ${optionalProps.map(p => `'${p.name}'`).join(' | ')}>;`);
  }

  // Variant types
  if (variantProps.length > 0) {
    variantProps.forEach(prop => {
      if (prop.type.includes('|')) {
        const typeName = `${componentName}${toPascalCase(prop.name)}`;
        utilityTypes.push(`/**
 * ${prop.name} options for ${componentName}
 */
export type ${typeName} = ${prop.type};`);
      }
    });
  }

  // Partial props type
  utilityTypes.push(`/**
 * Partial props for ${componentName} (all optional)
 */
export type ${componentName}PartialProps = Partial<${componentName}Props>;`);

  // Default props type
  utilityTypes.push(`/**
 * Default props with required fields
 */
export type ${componentName}WithDefaults = Prettify<
  ${requiredProps.length > 0 ? `${componentName}RequiredProps & ` : ''}Partial<${componentName}OptionalProps>
>;`);

  return utilityTypes.join('\n\n');
}

function generateConstants(
  componentName: string,
  component: Component
): string {
  const constants: string[] = [];

  // Default props
  constants.push(`/**
 * Default props for ${componentName}
 */
export const ${componentName.toUpperCase()}_DEFAULTS: ${componentName}Config = {
  variant: 'default',
  size: 'md',
  theme: 'light',
  animation: {
    duration: 200,
    easing: 'ease-in-out',
    disabled: false,
  },
  accessibility: {
    role: 'region',
  },
};`);

  // Variant constants
  constants.push(`/**
 * Available variants for ${componentName}
 */
export const ${componentName.toUpperCase()}_VARIANTS = {
  DEFAULT: 'default',
  OUTLINE: 'outline',
  GHOST: 'ghost',
} as const;`);

  // Size constants
  constants.push(`/**
 * Available sizes for ${componentName}
 */
export const ${componentName.toUpperCase()}_SIZES = {
  SMALL: 'sm',
  MEDIUM: 'md',
  LARGE: 'lg',
} as const;`);

  return constants.join('\n\n');
}

function generateHelperFunctions(
  componentName: string,
  props: PropDefinition[],
  options: CodeGeneratorOptions
): string {
  const functions: string[] = [];

  // Prop validator function
  functions.push(`/**
 * Validates ${componentName} props
 */
export function validate${componentName}Props(props: ${componentName}Props): boolean {
  // Add validation logic here
  const requiredProps = [${props
    .filter(p => p.required)
    .map(p => `'${p.name}'`)
    .join(', ')}];

  for (const prop of requiredProps) {
    if (!(prop in props) || props[prop as keyof ${componentName}Props] === undefined) {
      console.warn(\`Missing required prop: \${prop}\`);
      return false;
    }
  }

  return true;
}`);

  // Default props merger
  functions.push(`/**
 * Merges user props with default props
 */
export function merge${componentName}Props(
  userProps: Partial<${componentName}Props>,
  defaults: ${componentName}Config = ${componentName.toUpperCase()}_DEFAULTS
): ${componentName}Props {
  return {
    ...defaults,
    ...userProps,
  } as ${componentName}Props;
}`);

  // Props picker utility
  functions.push(`/**
 * Picks specific props from ${componentName}Props
 */
export function pick${componentName}Props<K extends keyof ${componentName}Props>(
  props: ${componentName}Props,
  keys: K[]
): Pick<${componentName}Props, K> {
  const result = {} as Pick<${componentName}Props, K>;

  for (const key of keys) {
    if (key in props) {
      result[key] = props[key];
    }
  }

  return result;
}`);

  // Type guard function
  functions.push(`/**
 * Type guard to check if object is ${componentName}Props
 */
export function is${componentName}Props(obj: any): obj is ${componentName}Props {
  if (!obj || typeof obj !== 'object') return false;

  // Add specific prop checks here
  return true;
}`);

  return functions.join('\n\n');
}

function generateExports(componentName: string): string {
  return `/**
 * Re-export all types and utilities
 */
export type {
  ${componentName}Props,
  ${componentName}Config,
  ${componentName}RequiredProps,
  ${componentName}OptionalProps,
  ${componentName}PartialProps,
  ${componentName}WithDefaults,
};

export {
  ${componentName.toUpperCase()}_DEFAULTS,
  ${componentName.toUpperCase()}_VARIANTS,
  ${componentName.toUpperCase()}_SIZES,
  validate${componentName}Props,
  merge${componentName}Props,
  pick${componentName}Props,
  is${componentName}Props,
};`;
}

function getDefaultProps(): PropDefinition[] {
  return [
    {
      name: 'className',
      type: 'string',
      required: false,
      description: 'Additional CSS classes to apply to the component',
    },
    {
      name: 'children',
      type: 'React.ReactNode',
      required: false,
      description: 'Child elements to render inside the component',
    },
    {
      name: 'variant',
      type: "'default' | 'outline' | 'ghost'",
      required: false,
      defaultValue: 'default',
      description: 'Visual style variant of the component',
    },
    {
      name: 'size',
      type: "'sm' | 'md' | 'lg'",
      required: false,
      defaultValue: 'md',
      description: 'Size of the component',
    },
  ];
}
